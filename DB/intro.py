'''
PostgreSQL - Система управления базами данных (СУБД/DBMS) 
Это ряд программ и инструментов, позволяющих создавать базы данных, управлять ею и манипулировать данными внутри БД (создавать, считывать, корректировать и удалять (CRUD)).

Postgres - База данных, она реалиционна, то есть данные хранятся в виде таблиц, и таблицы имеют связи между собой (relations).

SQL (Structured Query Language) - язык запросов - декларативный язык структурированных запросов, он применяется для создания и управления данными.
'''

'''Команды:'''
'''-----------------------------------------------------------------------'''
'''Связи между таблицами (relations):'''
# 1. Один к одному (one to one) - человек паспорт
# 2. Один ко многим (one to many) - человек и банковские карты
# 3. Много ко многим (many to many) - студенты и преподы, разработчики и проекты


'''Constraints (Ограничения):'''
#     1. CHECK <column> > 5 - проверка данных по условию
#     2. UNIQUE - уникальное значение, не повторяется в поле
#     3. NOT NULL - обязательно к заполнению
#     4. DEFAULT - добавляет дефолтное значение
#     5. PRIMARY KEY (для установки идентификатора данных в таблице)
#     6. FOREIGN KEY (для установки связи между таблицами)


'''Добавление:'''
# ALRET TABLE products ADD CHECK (name <> '');
# ALTER TABLE products ADD CONSTRAINT <name_of_constr> UNIQUE (name);
# ALTER TABLE cities ALTER COLUMN location SET NOT NULL;

'''-----------------------------------------------------------------------'''

# ubuntu: sudo -u postgres psql ->  для входа
# mac: psql postgres ->  для входа

# psql -> команда для входа через своего юзера

# \q -> выход из СУБД

# \du -> список всех юзеров

# \l -> список всех БД

# \c <dbname> -> команда для подключения к БД
#       \dt -> список таблиц в БД
#       \d <table name> -> подробная информация про таблицу

'''Пример заполнения таблицы в postgres'''
# id  |   name    | price     | owner | contacts  | description   | images        | see
# 556 | 'Lexus'   | 3_000_000 | 'Mura'| 453214255 | 'data'        | 'http://...'  | 9000


'''Типы полей в Postgres'''
# 1. Numeric types:
#   a. smallint (2 bytes) -> -32767 to 32767
#   b. integer (4 bytes) -> -2147000 to 2147000
#   c. bigint (8 bytes) -> ...
#   d. serial (4 bytes) -> auto-increment (integer, 1-2147000)
#   e. real (4 bytes) -> число с плавающей точкой, вещественное число
#   f. double precision (8 bytes) - real но только с двойной точностью

# 2. Character types:
#   a. varchar (кол-во 255) - можем указать макс кол-во символов вручную. Если мы указали макс кол-во символов в 50, а заполнили только 10, то остальные 40 не заполнятся.
#   b. char (255) - если не заполним все символы, то остальные заполнятся пробелами.
#   c. text - неограниченное кол-во символов

# 3. Boolean types:
#   boolean (1 byte) -> True/False

# 4. Date - календарная дата (гг/мм/дд)

# 5. Location (point) - координатная точка -> (245, -12) (x, y) - долгота, широта

'''ИМПОРТ данных при помощи файла'''
# psql -U <username> -d <database> -f <path_to_file>


# CREATE DATABASE <dbname>; -> команда для создания БД
# DROP ... -> удаление 


# CREATE TABLE <tablename> (
#   <name_of_column> <type>, 
#   <name_of_column> <type> 
#   ); - команда для создания таблицы
# CREATE TABLE weather (
    # city varchar(100),
    # temp_lo int,
    # temp_hi int,
    # prcp real,
    # date date
    # );


# DROP DATABASE <name_of_db>; - удаление БД


# DROP TABLE <name_of_table>; - удаление таблицы


# INSERT INTO <table_name> (<columns>) VALUES (<datas_to_columns>); - команда для заполнения данных в таблицу
# INSERT INTO cities (name, location) VALUES ('Bishkek', '(42.52, 74.59)');


# UPDATE <table_name> SET <row> = <new_value> 
# WHERE <row> = <value>; - команда для обновления данных
# Указываем после оператора WHERE то, какой объект обновить


# DELETE FROM <tablename> WHERE <column> = <data>; - команда удаления


# CREATE USER <username> WITH PASSWORD '<password>'; -> команда для создания юзера


# ALTER USER <username> WITH SUPERUSER; -> команда для изменения статуса юзера на суперюзера


# SELECT <column> FROM <table>; - команда для получения данных по определенным столбцам


# WHERE: используется для фильтрации по полям, будут выводиться только те данные, которые соответствуют условию WHERE
# Синтаксис: SELECT <row> FROM <tablename> WHERE <row>='чему-либо'


# SELECT * FROM products WHERE meat = 'Becon';
# SELECT * FROM products WHERE meat in ('Becon', 'Beef');

'''Оператор AND для множества условий'''

'''Операторы сравнения: >, <, >=, <=, =, <>'''

'''Оператор BETWEEN (условие между)'''
# SELECT * FROM products WHERE id BETWEEN 3 and 8;
# SELECT * FROM products WHERE id >= 3 and id <= 8;

'''Оператор ORDER BY - сортировка по входящим данным по убыванию или возрастанию'''
# ASC (по возрастанию) и DESC (по убыванию)
# SELECT <row> FROM <table> ORDER BY <row> [ASC/DESC];

'''Оператор LIMIT - позволяет вернуть данные в ограниченном количестве'''
# SELECT <row> FROM <table> LIMIT 1; - вернет только 1 строку

'''Оператор LIKE - выводит результат, который соответствует введенному шаблону. Зависит от регистра.'''
'''Оператор ILIKE - выводит результат, который соответствует введенному шаблону. Не зависит от регистра.'''
# SELECT * FROM products WHERE name LIKE 'S%';


'''Оператор DISTINCT - позволяем нам убрать дубликаты и возвращает только уникальные значения'''
# SELECT DISTINCT name FROM products;

'''-----------------------------------------------------------------------------------------'''

'''GROUP BY:'''

# Разделяет данные,которые мы получаем в SELECT, при этом группируя их по определенному признаку, и теперь для каждой группы можно использовать агрегатную функцию.
    
# SELECT city, MAX(temp_hi), AVG(prcp) FROM weather GROUP BY city;

# HAVING: он работает так же, как и WHERE, только с оператором GROUP BY 

'''-----------------------------------------------------------------------------------------'''

'''JOIN:'''

# JOIN - оператор, который позволяет в запросах SELECT брать данные из нескольких таблиц

# INNER JOIN - достаются только те записи, у которых есть связь

# FULL JOIN - соединение таблиц, в которых достаются все данные с обеих таблиц

# LEFT JOIN - достает все записи с левой* таблицы, а с правой только те записи, у которых есть связь с левой таблицей

# RIGHT JOIN - достает все записи с правой* таблицы, а с левой только те записи, у которых есть связь с правой таблицей

        # * где "левая" таблица - это та таблица, которая записана до JOIN, а "правая" таблица - это та таблица, которая записана после JOIN

'''-----------------------------------------------------------------------------------------'''

